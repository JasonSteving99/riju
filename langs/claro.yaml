id: "claro"
name: "Claro"

install:
    apt:
      - default-jdk
    manual: |
      install -d "${pkg}/usr/local/bin"

      # Pull resources from the latest Claro repo release.
      ver="$(latest_release JasonSteving99/claro-lang)"

      # Pull the tarball of the built Bazel repo's bazel-bin instead of just the sources.
      wget "https://github.com/JasonSteving99/claro-lang/releases/download/${ver}/claro-lang-bazel-bin.tar.gz"
      tar -xzvf claro-lang-bazel-bin.tar.gz

      #####################################################################################################
      # We don't want to depend on Bazel at all for rebuilding, it's just one file changing. Rebuild it using
      # the packaged jar files and then update the jar holding that recompiled file and run the Bazel gen'd
      # run script which points at all the correct jar runfiles. First though, we need to slightly modify
      # the Bazel gen'd runscript to rebuild using the packaged jars for us (without explicitly rerunning Bazel
      # itself since this is super slow and involves starting up a new Bazel server...).
      pushd claro_programs/ > /dev/null
      fancydelim=$(printf '\001') # https://stackoverflow.com/a/25821096/10027370

      # For the purpose of rebuilding, we need lombok and autovalue on the classpath.
      MY_SCRIPT='  REBUILD_CLASSPATH="${CLASSPATH}"\n'
      MY_SCRIPT+='  REBUILD_CLASSPATH+=":lombok-1.18.20.jar"\n'
      MY_SCRIPT+='  REBUILD_CLASSPATH+=":auto-value-1.5.3.jar"\n'
      MY_SCRIPT+='  javac -classpath $REBUILD_CLASSPATH Conditions.java\n'
      # There's an assumption that the dir ./com/claro/ was made in the tarball before this.
      MY_SCRIPT+='  mv Conditions*.class com/claro\n'
      MY_SCRIPT+='  jar -uf "${RUNPATH}src/java/com/claro/claro_programs/conditions_compiled_claro_image.jar" com/claro/Conditions*.class\n'
      MY_SCRIPT+='  java -classpath $CLASSPATH "${ARGS[@]}"\n'
      # We insert our own exit here to short-circuit the Bazel run script's call to JAVABIN which is
      # invalid on this host machine.
      MY_SCRIPT+='  exit $?\n'

      # Insert MY_SCRIPT into the Bazel run script just before java gets executed. We're reusing Bazel's run
      # script basically just to get a conveniently curated CLASSPATH variable generated to point to all the
      # randomly scattered jar files that Bazel places throughout bazel-bin/.
      sed -n "H;\${x;s/\n//;s${fancydelim}create_and_run_classpath_jar\nelse\n${fancydelim}&${MY_SCRIPT}\n${fancydelim};p;}" conditions_compiled_claro_image > conditions_compiled_claro_image2

      # I'm not good enough with sed to figure out how to avoid this extra temporary stop in a second file. Oh well.
      chmod 777 conditions_compiled_claro_image
      cat conditions_compiled_claro_image2 > conditions_compiled_claro_image

      popd > /dev/null
      #####################################################################################################

      cp -R claro_programs "${pkg}/usr/local/bin"

      wget "https://github.com/JasonSteving99/claro-lang/releases/download/v0.1.0/claro_compiler_binary_deploy.jar"
      cp  claro_compiler_binary_deploy.jar "${pkg}/usr/local/bin"

setup: |
    cp -R /usr/local/bin/* "${HOME}/src"

main: "claro_programs/Conditions.claro"
template: |
    # Thanks for trying out Claro during its early development stages!
    # To learn Claro by example, check out:
    # https://clarolang.com/tree/main/src/java/com/claro/claro_programs

    print("Hello, world!");

run: |
    # Skip rebuilding the entire compiler all over again and instead just use the pre-built Claro compiler jar.
    chmod +rw claro_programs/Conditions.java
    java -jar claro_compiler_binary_deploy.jar --java_source --silent --classname=Conditions --package=com.claro \
        < claro_programs/Conditions.claro \
        > claro_programs/Conditions.java

    pushd claro_programs/ > /dev/null
    ./conditions_compiled_claro_image
    popd > /dev/null

repl: |
    java -jar claro_compiler_binary_deploy.jar --repl --silent